{"version":3,"file":"index.js","sources":["../src/js/6-module.js"],"sourcesContent":["//; Module №6 ООП. Класи\n\n//! 1 ------ Контекст виконання функції -------\n\n// #region  //: - Ключове слово this\n\n//; 1\n//* залежить в якому контексі викликається this\n//* залежить як саме функцію викликати, а не де вона була оголошена\n\n/* const hangar = {\n  ships: ['shadow', 'fire star', ' bolid bomber'],\n\n  checkStatus(name) {\n    return this.ships.includes(name);\n  },\n\n  isItReady(name) {\n    const isItReadyGo = this.checkStatus(name);\n    if (!isItReadyGo) {\n      return 'Sory no kind of ships on board';\n    }\n    return `ship ${name} is ready to travel`;\n  },\n}; */\n\n//; 2\n\n// #endregion\n\n// #region  //: - Глобальний контекст\n\n//* в глобальному без стрікт = window . у strict моді = undefined\n\n/* function foo() {\n  console.log(this);\n}\nfoo(); */\n\n// #endregion\n\n// #region  //: - Контекст методу об'єкта\n\n//; 1\n//* функція викликана як метод обʼєкта тому контекс вказує на сам обʼєкт\n/* const user = {\n  username: 'Mark',\n  age: 25,\n\n  showThis() {\n    console.log(this);\n  },\n};\n\nuser.showThis(); */\n\n//; 2\n//* спочатку глобальна функція в суворому режимі\n\n/* ('use strict');\n\nfunction showThis() {\n  console.log('this is showThis: ', this); // this is shiwThis: undefined\n}\n */\n//* потім присвоюємо цю функцію ключу обʼєкта і викликаємо її як функцію (метод) цього обʼєкта\n\n/* const user = {\n  username: 'Mark',\n};\n\nuser.showContext = showThis;\n\nuser.showContext();\n\nshowThis();\n */\n// #endregion\n\n// #region  //: - Метод call()\n//? метод використовується тоді коли треба викликати функцію яка не є методом обʼєкта\n//? методи call, apply, bind вказують на контекст виклику функції\n\n//; foo.call(thisArg, arg1,arg2,...)\n\n//? thisArg - обʼєкт яким ми хочемо встановити як контекст (значення this) для функції\n//? arg1,arg2,... - необовʼязкові аргументи які будуть передані функції\n//? метод call викликає функціяю foo так, що значення this у функції буде посилатися на обʼєкт this Args і також передає їй аргументи arg1, arg2\n\n/* function greet(str) {\n  console.log(`${str}, ${this.username}, your room is ${this.room}!`);\n}\n\nconst mango = {\n  username: 'Mango',\n  room: 191,\n};\n\nconst poly = {\n  username: 'Poly',\n  room: 191,\n};\n\ngreet.call(mango, 'Welcome');\ngreet.call(poly, 'Aloha'); */\n\n// #endregion\n\n// #region  //: - Метод apply()\n\n//? метод вимагає масиву на відміну від call .\n//? все остальне таке саме\n//; foo.apply(thisArg, [arg1, arg2, ...])\n\n/* function greet(str) {\n  console.log(`${str}, ${this.username}, your room is ${this.room}!`);\n}\n\nconst mango = {\n  username: 'Mango',\n  room: 27,\n};\n\nconst poly = {\n  username: 'Poly',\n  room: 191,\n};\n\ngreet.apply(mango, ['Welcome']);\ngreet.apply(poly, ['Aloha']); */\n\n// #endregion\n\n// #region  //: - Метод bind() і втрата контексту\n\n//; const boundFoo = foo.bind(thisArg, arg1, arg2, ...)\n//? thisArg - обʼєкт яким ми хочемо встановити як контекст (значення this) для функції\n//? arg1,arg2,... - необовʼязкові аргументи які будуть передані функції\n\n'use strict';\n\n/* const customer = {\n  username: 'Jacob',\n  sayHello() {\n    console.log(`Hello, ${this.username}!`);\n  },\n};\n\ncustomer.sayHello;\n\n//^ const greet = customer.sayHello;  виклече помилку\nconst greet = customer.sayHello.bind(customer); //? bind(customer) дає знати до чого це відноситься\n\ngreet(); */\n// при використанні bind() ми створюємо НОВУ функцію greet із правильним контекстом і\n// може використовувати властивість username обʼєкта customer\n\n// #endregion\n\n// #region  //: - Метод bind() і колбеки\n\n//? метод bind є корисним і його варто застосовувати у callback функціях\n\n/* 'use strict';\n\nconst customer = {\n  firstName: 'Jacob',\n  lastName: 'Mercer',\n\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n};\n\nfunction makeMessage(callback) {\n  // callback() - це виклик методу getFullName в глобальному контексті\n  const username = callback();\n  console.log(`Processing an aplication from ${username}`);\n}\n\n//^ makeMessage(customer.getFullName); помилка бо втрачає контекст через метод\n//^ getFullName\nmakeMessage(customer.getFullName.bind(customer)); */\n\n// #endregion\n\n// #region  //: - Стрілочні функції\n\n//? контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n//? this усередині стрілки посилається на контект батьківської області видимості в якій\n//? вона була оголошена і ніколи не змінюється\n\n//? this посилається на обʼєкт\n//; 1\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis(); // this in showThis: window */\n\n//; 2\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nconst user = {\n  username: 'Mango',\n};\n\nuser.showContext = showThis;\nuser.showContext(); //thi in showThis:window\n */\n\n//; 3\n//? ігнорують наявність суворого режиму\n\n/* 'use strict';\n\nconst showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis(); // this in showThis: window\n */\n\n//; 4\n\n//? стрілки запамятовують контекст під час виклику\n\n/* const hotel = {\n  username: 'Resort hotel',\n  showThis() {\n    const foo = () => {\n      console.log('this in foo ', this);\n    };\n    foo();\n    console.log('this in showThis ', this);\n  },\n};\n\nhotel.showThis(); */\n// this in foo: {username: 'Resort hotel', showThis: ƒ}\n// this in showThis: {username: 'Resort hotel',showThis: ƒ}\n\n//; 5\n\n//? 1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n//? 2.Стрілочні функції ігнорують наявність суворого режиму. Тому в глобальному контексті у стрілці завжди this посилається на об'єкт window.\n//? 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення. Методи call, apply і bind не впливають на значення this у стрілках.\n\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis.call({ username: 'Mango' }); // this in showThis: window\nshowThis.apply({ username: 'Mango' }); // this in showThis: window\n\nconst boundShowThis = showThis.bind({ username: 'Mango' }); */\n\n// #endregion\n\n// #endregion\n\n//! 2 ------ Прототипи -------\n\n// #region  //: - Прототип об'єкта\n\n//? Отже, прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку\n\n//; 1\n\n/* const animal = {\n  legs: 4,\n};\n\nconst dog = Object.create(animal); //* незнаходить legs тому шукає через прототип animal\ndog.name = 'Asti'; //* працює очевидним чином\n\nconsole.log(dog); // {name: \"Asti\"}\n\nconsole.log(dog.name); // \"Mango\"\nconsole.log(dog.legs); // 4\n */\n\n//; 2\n\n/* const parent = {\n  name: 'Stacey',\n  surname: 'Moore',\n  age: 54,\n  heritage: 'Irish',\n};\n\nconst child = Object.create(parent);\nchild.name = 'Jason';\nchild.age = 27;\n\nconsole.log(child.hasOwnProperty('surname'));\nconsole.log(child.surname);\n */\n//; 3\n\n/* const spaceShip = {\n  name: 'Black Star',\n  id: 4003,\n  fuel: 100,\n};\n\nconst hangar = Object.create(spaceShip);\nhangar.guns = 1000;\n\nconsole.log(hangar.fuel); */\n\n//; 4\n\n/* const hangarA = {\n  ships: 40,\n  crew: 200,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.shipsB = 20;\n\nconsole.log(hangarB.crew);\n */\n// #endregion\n\n// #region  //: - Перевірка прототипу\n//? Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().\n//; objA.isPrototypeOf(objB)\n//? objA перевіряє чи я протопимов для обʼєкта objB якщо так то true якщо ні то false\n\n/* const asteroidsField = {\n  asteroidsNumber: 147927,\n};\n\nconst hangar = {\n  ships: 34,\n};\n\nconst fighters = Object.create(hangar);\nfighters.id = 'A1';\n\nconsole.log(fighters);\n\nconsole.log(hangar.isPrototypeOf(fighters));\nconsole.log(hangar.isPrototypeOf(asteroidsField));\nconsole.log(fighters.isPrototypeOf(asteroidsField));\nconsole.log(fighters.isPrototypeOf(hangar)); */\n\n//; 2\n\n/* const hangarA = {\n  crew: 200,\n  ships: 20,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 100;\n\nconsole.log(hangarA.isPrototypeOf(hangarB));\n */\n// #endregion\n\n// #region  //: - Власні і невласні властивості\n//; obj.hasOwnProperty(key) - для перевірки обʼкту\n\n//; 1\n/* const asteroidsField = {\n  asteroidsNumber: 147927,\n};\n\nconst hangar = {\n  //? невласна властивість\n  ships: 34,\n};\n\nconst fighters = Object.create(hangar);\nfighters.id = 'A1'; //? власа властивість\n\nconsole.log(fighters.hasOwnProperty('ships')); */\n\n//; 2\n\n/* const hangarA = {\n  crew: 100,\n  ships: 23,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 400;\n\nfor (const key in hangarB) {\n  console.log(key);\n}\n\nfor (const key in hangarB) {\n  console.log(hangarB.hasOwnProperty(key));\n}\n\nconsole.log(Object.keys(hangarA));\nconsole.log(Object.keys(hangarB));\n\nconsole.log(Object.values(hangarA));\nconsole.log(Object.values(hangarB)); */\n\n// #endregion\n\n// #region  //: - Перебір власних властивостей\n\n/* const hangarA = {\n  crew: 100,\n  ships: 23,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 400;\n\nfor (const key in hangarB) {\n  console.log(key);\n}\n\nfor (const key in hangarB) {\n  console.log(hangarB.hasOwnProperty(key));\n}\n\nconsole.log(Object.keys(hangarA));\nconsole.log(Object.keys(hangarB));\n\nconsole.log(Object.values(hangarA));\nconsole.log(Object.values(hangarB)); */\n\n// #endregion\n\n// #region  //: - Ланцюжки прототипів\n\n/* const objC = {\n  c: 'Obj C property',\n};\n\nconst objB = Object.create(objC);\nobjB.b = 'Obj B property';\n\nconst objA = Object.create(objB);\nobjA.a = 'Obj A property';\n\nconsole.log(objA);\nconsole.log(objC);\nconsole.log(objB); */\n\n// #endregion\n\n// #region  //: - Кінець ланцюжка прототипів\n\n// #endregion\n\n//! 3 ------  Модуль 6. ООП. Класи -------\n\n// #region  //: - Процедурне програмування\n\n//? Приклад процедурного коду\n/* const baseSalary = 30000;\nconst overtime = 10;\nconst rate = 20;\n\nconst getWage = (baseSalary, overtime, rate) => {\n  return baseSalary + overtime * rate;\n};\n\ngetWage(baseSalary, overtime, rate);\n */\n\n//^ Процедурне програмування — це те, як ми з тобою писали код до сих пір. Воно є простим і зрозумілим і може бути використане для написання простих програм. Проте зі збільшенням складності програми процедурний підхід може стати неефективним, оскільки втрачається зв'язок між даними й методами їх обробки.\n\n// #endregion\n\n// #region  //: - Об'єктно-орієнтоване програмування\n\nconst employee = {\n  baseSalaty: 30000,\n  overtime: 10,\n  rate: 20,\n  getWage() {\n    return this.baseSalaty + this.overtime * this.rate;\n  },\n};\n\nemployee.getWage();\n\n//^ При такому підході відсутні або майже відсутні глобальні змінні. Методи не залежать від параметрів, а використовують властивості об'єкта, які задаються при його створенні і можуть бути змінені іншими методами.\n\n// #endregion\n\n// #region  //: - Клас\n\n//? як абстрактний автомобіль чи схема в які описано методи та обєкти\n\n// #endregion\n\n// #region  //: - Екземпляр класу\n\n//? це конкретний автомобіль яким можна керувати за допомогою інтерсфейчу класу\n// #endregion\n\n//! 4 ------  Класи -------\n// #region  //: - Оголошення класу\n\n//? Оголоішення класу має такий синтаксис\n//? ключове слово  class\n//? імʼя класу (user)\n//? тіло класу у фігурних дужках\n//? Класи прийнято називати з великої літери, а в назві відображати тип об'єкта (іменника), що створюється.\n\n//^ створюємо класс\n/* class User {\n  //* тіло класу \n} */\n\n//^ створюємо  екземпляр  за допомоною оператора  new\n//^ поставивши його перед викликом класу new User() буде містити дані і дії що\n//^ описані в тілі класу\n\n/* class User {}\n\nconst mango = new User();\nconsole.log(mango); */\n\n// #endregion\n\n// #region  //: - Конструктор класу\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n//; 5 ------ Задачі -------\n// #region  //; - Задачі\n\n// #endregion\n"],"names":["employee"],"mappings":"ssBAuQA;AAiMA;AAsBA,MAAMA,EAAW,CACf,WAAY,IACZ,SAAU,GACV,KAAM,GACN,SAAU,CACR,OAAO,KAAK,WAAa,KAAK,SAAW,KAAK,IAC/C,CACH,EAEAA,EAAS,QAAO,EAiBhB;"}