{"version":3,"file":"index.js","sources":["../src/js/6-module.js","../src/js/8-module.js"],"sourcesContent":["//; Module №6 ООП. Класи\n\n//! 1 ------ Контекст виконання функції -------\n\n// #region  //: - Ключове слово this\n\n//; 1\n//* залежить в якому контексі викликається this\n//* залежить як саме функцію викликати, а не де вона була оголошена\n\n/* const hangar = {\n  ships: ['shadow', 'fire star', ' bolid bomber'],\n\n  checkStatus(name) {\n    return this.ships.includes(name);\n  },\n\n  isItReady(name) {\n    const isItReadyGo = this.checkStatus(name);\n    if (!isItReadyGo) {\n      return 'Sory no kind of ships on board';\n    }\n    return `ship ${name} is ready to travel`;\n  },\n}; */\n\n//; 2\n\n// #endregion\n\n// #region  //: - Глобальний контекст\n\n//* в глобальному без стрікт = window . у strict моді = undefined\n\n/* function foo() {\n  console.log(this);\n}\nfoo(); */\n\n// #endregion\n\n// #region  //: - Контекст методу об'єкта\n\n//; 1\n//* функція викликана як метод обʼєкта тому контекс вказує на сам обʼєкт\n/* const user = {\n  username: 'Mark',\n  age: 25,\n\n  showThis() {\n    console.log(this);\n  },\n};\n\nuser.showThis(); */\n\n//; 2\n//* спочатку глобальна функція в суворому режимі\n\n/* ('use strict');\n\nfunction showThis() {\n  console.log('this is showThis: ', this); // this is shiwThis: undefined\n}\n */\n//* потім присвоюємо цю функцію ключу обʼєкта і викликаємо її як функцію (метод) цього обʼєкта\n\n/* const user = {\n  username: 'Mark',\n};\n\nuser.showContext = showThis;\n\nuser.showContext();\n\nshowThis();\n */\n// #endregion\n\n// #region  //: - Метод call()\n//? метод використовується тоді коли треба викликати функцію яка не є методом обʼєкта\n//? методи call, apply, bind вказують на контекст виклику функції\n\n//; foo.call(thisArg, arg1,arg2,...)\n\n//? thisArg - обʼєкт яким ми хочемо встановити як контекст (значення this) для функції\n//? arg1,arg2,... - необовʼязкові аргументи які будуть передані функції\n//? метод call викликає функціяю foo так, що значення this у функції буде посилатися на обʼєкт this Args і також передає їй аргументи arg1, arg2\n\n/* function greet(str) {\n  console.log(`${str}, ${this.username}, your room is ${this.room}!`);\n}\n\nconst mango = {\n  username: 'Mango',\n  room: 191,\n};\n\nconst poly = {\n  username: 'Poly',\n  room: 191,\n};\n\ngreet.call(mango, 'Welcome');\ngreet.call(poly, 'Aloha'); */\n\n// #endregion\n\n// #region  //: - Метод apply()\n\n//? метод вимагає масиву на відміну від call .\n//? все остальне таке саме\n//; foo.apply(thisArg, [arg1, arg2, ...])\n\n/* function greet(str) {\n  console.log(`${str}, ${this.username}, your room is ${this.room}!`);\n}\n\nconst mango = {\n  username: 'Mango',\n  room: 27,\n};\n\nconst poly = {\n  username: 'Poly',\n  room: 191,\n};\n\ngreet.apply(mango, ['Welcome']);\ngreet.apply(poly, ['Aloha']); */\n\n// #endregion\n\n// #region  //: - Метод bind() і втрата контексту\n\n//; const boundFoo = foo.bind(thisArg, arg1, arg2, ...)\n//? thisArg - обʼєкт яким ми хочемо встановити як контекст (значення this) для функції\n//? arg1,arg2,... - необовʼязкові аргументи які будуть передані функції\n\n'use strict';\n\n/* const customer = {\n  username: 'Jacob',\n  sayHello() {\n    console.log(`Hello, ${this.username}!`);\n  },\n};\n\ncustomer.sayHello;\n\n//^ const greet = customer.sayHello;  виклече помилку\nconst greet = customer.sayHello.bind(customer); //? bind(customer) дає знати до чого це відноситься\n\ngreet(); */\n// при використанні bind() ми створюємо НОВУ функцію greet із правильним контекстом і\n// може використовувати властивість username обʼєкта customer\n\n// #endregion\n\n// #region  //: - Метод bind() і колбеки\n\n//? метод bind є корисним і його варто застосовувати у callback функціях\n\n/* 'use strict';\n\nconst customer = {\n  firstName: 'Jacob',\n  lastName: 'Mercer',\n\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n};\n\nfunction makeMessage(callback) {\n  // callback() - це виклик методу getFullName в глобальному контексті\n  const username = callback();\n  console.log(`Processing an aplication from ${username}`);\n}\n\n//^ makeMessage(customer.getFullName); помилка бо втрачає контекст через метод\n//^ getFullName\nmakeMessage(customer.getFullName.bind(customer)); */\n\n// #endregion\n\n// #region  //: - Стрілочні функції\n\n//? контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n//? this усередині стрілки посилається на контект батьківської області видимості в якій\n//? вона була оголошена і ніколи не змінюється\n\n//? this посилається на обʼєкт\n//; 1\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis(); // this in showThis: window */\n\n//; 2\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nconst user = {\n  username: 'Mango',\n};\n\nuser.showContext = showThis;\nuser.showContext(); //thi in showThis:window\n */\n\n//; 3\n//? ігнорують наявність суворого режиму\n\n/* 'use strict';\n\nconst showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis(); // this in showThis: window\n */\n\n//; 4\n\n//? стрілки запамятовують контекст під час виклику\n\n/* const hotel = {\n  username: 'Resort hotel',\n  showThis() {\n    const foo = () => {\n      console.log('this in foo ', this);\n    };\n    foo();\n    console.log('this in showThis ', this);\n  },\n};\n\nhotel.showThis(); */\n// this in foo: {username: 'Resort hotel', showThis: ƒ}\n// this in showThis: {username: 'Resort hotel',showThis: ƒ}\n\n//; 5\n\n//? 1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.\n//? 2.Стрілочні функції ігнорують наявність суворого режиму. Тому в глобальному контексті у стрілці завжди this посилається на об'єкт window.\n//? 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення. Методи call, apply і bind не впливають на значення this у стрілках.\n\n/* const showThis = () => {\n  console.log('this in showThis: ', this);\n};\n\nshowThis.call({ username: 'Mango' }); // this in showThis: window\nshowThis.apply({ username: 'Mango' }); // this in showThis: window\n\nconst boundShowThis = showThis.bind({ username: 'Mango' }); */\n\n// #endregion\n\n//! 2 ------ Прототипи -------\n\n// #region  //: - Прототип об'єкта\n\n//? Отже, прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку\n\n//; 1\n\n/* const animal = {\n  legs: 4,\n};\n\nconst dog = Object.create(animal); //* незнаходить legs тому шукає через прототип animal\ndog.name = 'Asti'; //* працює очевидним чином\n\nconsole.log(dog); // {name: \"Asti\"}\n\nconsole.log(dog.name); // \"Mango\"\nconsole.log(dog.legs); // 4\n */\n\n//; 2\n\n/* const parent = {\n  name: 'Stacey',\n  surname: 'Moore',\n  age: 54,\n  heritage: 'Irish',\n};\n\nconst child = Object.create(parent);\nchild.name = 'Jason';\nchild.age = 27;\n\nconsole.log(child.hasOwnProperty('surname'));\nconsole.log(child.surname);\n */\n//; 3\n\n/* const spaceShip = {\n  name: 'Black Star',\n  id: 4003,\n  fuel: 100,\n};\n\nconst hangar = Object.create(spaceShip);\nhangar.guns = 1000;\n\nconsole.log(hangar.fuel); */\n\n//; 4\n\n/* const hangarA = {\n  ships: 40,\n  crew: 200,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.shipsB = 20;\n\nconsole.log(hangarB.crew);\n */\n// #endregion\n\n// #region  //: - Перевірка прототипу\n//? Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().\n//; objA.isPrototypeOf(objB)\n//? objA перевіряє чи я протопимов для обʼєкта objB якщо так то true якщо ні то false\n\n/* const asteroidsField = {\n  asteroidsNumber: 147927,\n};\n\nconst hangar = {\n  ships: 34,\n};\n\nconst fighters = Object.create(hangar);\nfighters.id = 'A1';\n\nconsole.log(fighters);\n\nconsole.log(hangar.isPrototypeOf(fighters));\nconsole.log(hangar.isPrototypeOf(asteroidsField));\nconsole.log(fighters.isPrototypeOf(asteroidsField));\nconsole.log(fighters.isPrototypeOf(hangar)); */\n\n//; 2\n\n/* const hangarA = {\n  crew: 200,\n  ships: 20,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 100;\n\nconsole.log(hangarA.isPrototypeOf(hangarB));\n */\n// #endregion\n\n// #region  //: - Власні і невласні властивості\n//; obj.hasOwnProperty(key) - для перевірки обʼкту\n\n//; 1\n/* const asteroidsField = {\n  asteroidsNumber: 147927,\n};\n\nconst hangar = {\n  //? невласна властивість\n  ships: 34,\n};\n\nconst fighters = Object.create(hangar);\nfighters.id = 'A1'; //? власа властивість\n\nconsole.log(fighters.hasOwnProperty('ships')); */\n\n//; 2\n\n/* const hangarA = {\n  crew: 100,\n  ships: 23,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 400;\n\nfor (const key in hangarB) {\n  console.log(key);\n}\n\nfor (const key in hangarB) {\n  console.log(hangarB.hasOwnProperty(key));\n}\n\nconsole.log(Object.keys(hangarA));\nconsole.log(Object.keys(hangarB));\n\nconsole.log(Object.values(hangarA));\nconsole.log(Object.values(hangarB)); */\n\n// #endregion\n\n// #region  //: - Перебір власних властивостей\n\n/* const hangarA = {\n  crew: 100,\n  ships: 23,\n};\n\nconst hangarB = Object.create(hangarA);\nhangarB.fuel = 400;\n\nfor (const key in hangarB) {\n  console.log(key);\n}\n\nfor (const key in hangarB) {\n  console.log(hangarB.hasOwnProperty(key));\n}\n\nconsole.log(Object.keys(hangarA));\nconsole.log(Object.keys(hangarB));\n\nconsole.log(Object.values(hangarA));\nconsole.log(Object.values(hangarB)); */\n\n// #endregion\n\n// #region  //: - Ланцюжки прототипів\n\n/* const objC = {\n  c: 'Obj C property',\n};\n\nconst objB = Object.create(objC);\nobjB.b = 'Obj B property';\n\nconst objA = Object.create(objB);\nobjA.a = 'Obj A property';\n\nconsole.log(objA);\nconsole.log(objC);\nconsole.log(objB); */\n\n// #endregion\n\n// #region  //: - Кінець ланцюжка прототипів\n\n// #endregion\n\n//! 3 ------  Модуль 6. ООП. Класи -------\n\n// #region  //: - Процедурне програмування\n\n//? Приклад процедурного коду\n/* const baseSalary = 30000;\nconst overtime = 10;\nconst rate = 20;\n\nconst getWage = (baseSalary, overtime, rate) => {\n  return baseSalary + overtime * rate;\n};\n\ngetWage(baseSalary, overtime, rate);\n */\n\n//^ Процедурне програмування — це те, як ми з тобою писали код до сих пір. Воно є простим і зрозумілим і може бути використане для написання простих програм. Проте зі збільшенням складності програми процедурний підхід може стати неефективним, оскільки втрачається зв'язок між даними й методами їх обробки.\n\n// #endregion\n\n// #region  //: - Об'єктно-орієнтоване програмування\n\nconst employee = {\n  baseSalaty: 30000,\n  overtime: 10,\n  rate: 20,\n  getWage() {\n    return this.baseSalaty + this.overtime * this.rate;\n  },\n};\n\nemployee.getWage();\n\n//^ При такому підході відсутні або майже відсутні глобальні змінні. Методи не залежать від параметрів, а використовують властивості об'єкта, які задаються при його створенні і можуть бути змінені іншими методами.\n\n// #endregion\n\n// #region  //: - Клас\n\n//? як абстрактний автомобіль чи схема в які описано методи та обєкти\n\n// #endregion\n\n// #region  //: - Екземпляр класу\n\n//? це конкретний автомобіль яким можна керувати за допомогою інтерсфейчу класу\n// #endregion\n\n//! 4 ------  Класи -------\n\n// #region  //: - Оголошення класу\n\n//? Оголоішення класу має такий синтаксис\n//? ключове слово  class\n//? імʼя класу (user)\n//? тіло класу у фігурних дужках\n//? Класи прийнято називати з великої літери, а в назві відображати тип об'єкта (іменника), що створюється.\n\n//^ створюємо класс\n/* class User {\n  //* тіло класу \n} */\n\n//^ створюємо  екземпляр  за допомоною оператора  new\n//^ поставивши його перед викликом класу new User() буде містити дані і дії що\n//^ описані в тілі класу\n\n/* const mango = new User();\nconsole.log(mango);  */\n\n// #endregion\n\n// #region  //: - Конструктор класу\n\n//? Для ініціалізації екземпляра класу використовується метод - constructor -.\n// якщо він не визначний то буде створений конст за замовучваня - порожня функція\n// яка не змінює екземпляр класу\n\n/* class User {\n   // синтаксис оголошення методу класу\n  constructor( ){\n   //... }\n} */\n\n//? виклик класу оператором - new - призводить до створення нового обʼкта та\n//? автоматичного виклику методу - constructor -\n\n//; 1\n/* class User {\n  constructor() {\n    console.log('constructor call - message');\n  }\n}\n\nconst mango = new User(); // constructor - call message\nconsole.log(mango); */\n\n//; 2\n//?Аргументи, які передаються при виклику new User(), стають значеннями параметрів для методу constructor.\n/* class User {\n  constructor(name, email) {\n    console.log(name, email);\n  }\n}\n\nconst mango = new User('Mango', 'mango@gmail.com');\nconsole.log(mango); */\n\n//; 3\n//? зверни увагу що конструктор викликається в контексі створюваного екземпляра\n\n/* class User {\n  constructor(name, email) {\n    // ініціалізація властивостей екземпляра\n    this.name = name;\n    this.email = email;\n  }\n}\n\nconst mango = new User('Mango', 'mango@gmail.com');\nconsole.log(mango); */\n\n//? Таким чином, this усередині конструктора посилається на новостворений об'єкт.\n//? Це дозволяє надавати кожному об'єкту властивості з однаковими іменами, але різними значеннями.\n//? Властивості name та email називаються публічними властивостями, оскільки вони є власними властивостями об'єкта-екземпляра.\n\n// #endregion\n\n// #region  //: - Об'єкт параметрів\n\n/* class User {\n  constructor(params) {\n    this.name = params.name;\n    this.email = params.email;\n    this.age = params.age;\n  }\n}\n\nconst mango = new User({\n  name: 'Mango',\n  email: 'mango@fdfdf',\n  age: 20,\n});\n\nconsole.log(mango); */\n\n// #endregion\n\n// #region  //: - Методи класу (функції)\n\n/* class User {\n  constructor(params) {\n    this.name = params.name;\n    this.email = params.email;\n  }\n\n  // методи НЕ розділяються комою\n  getEmail() {\n    return this.email;\n  }\n\n  changeEmail(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nconst mango = new User({\n  name: 'Mango',\n  email: 'mango@gmail.com',\n});\n\nconsole.log(mango.getEmail());\n\nmango.changeEmail('alex@gmail.com');\n\nconsole.log(mango.getEmail()); */\n\n// #endregion\n\n// #region  //: - Прототип екземпляру\n\n/* class User {\n  constructor(params) {\n    this.name = params.name;\n    this.email = params.email;\n  }\n\n  getEmail() {\n    return this.email;\n  }\n\n  changeEmail(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nconsole.log(User.prototype); // {constructor: ƒ, getEmail: ƒ, changeEmail: ƒ} */\n\n// #endregion\n\n// #region  //: - Приватні властивості\n\n//? # робить властивість приватною\n\n//; 1\n/* class User {\n  name;\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n}\n\nconst mango = new User({\n  name: 'Mango',\n  email: 'email@email',\n});\n\nconsole.log(mango.name); */\n\n//? Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.\n\n//; 2\n/* class User {\n  name;\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n\n  getEmail() {\n    return this.#email;\n  }\n\n  changeEmail(newEmail) {\n    this.#email = newEmail;\n  }\n}\n\nconst mango = new User({\n  name: 'Mango',\n  email: 'email@email',\n});\n\nconsole.log(mango.getEmail()); // \"mango@mail.com\"\nmango.changeEmail('mango@supermail.com');\nconsole.log(mango.getEmail()); // \"mango@supermail.com\" */\n\n//; 3\n\n/* class Car {\n  #brand;\n  constructor(params) {\n    this.#brand = params.brand;\n    this.model = params.model;\n    this.price = params.price;\n  }\n\n  getPrice() {\n    return this.price;\n  }\n  changePrice(newPrice) {\n    this.price = newPrice;\n  }\n  getBrand() {\n    return this.#brand;\n  }\n\n  changeBrand(newBrand) {\n    this.#brand = newBrand;\n  }\n}\n */\n// #endregion\n\n// #region  //: - Приватні методи\n\n/* class User {\n  name;\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n\n  // Публічний метод для отримання електронної пошти\n  getEmail() {\n    return this.#email;\n  }\n\n  // Публічний метод для заміни електронної пошти\n  changeEmail(newEmail) {\n    if (this.#validateEmail(newEmail)) {\n      this.#email = newEmail;\n    } else {\n      console.log('invalid email format');\n    }\n  }\n\n  // Привітний метод для валідації електронної пошти\n  #validateEmail(email) {\n    return email.includes('@');\n  }\n}\nconst mango = new User({\n  name: 'Mango',\n  email: 'mango@mail.com',\n});\n\n// Спробуємо змінити електронну пошту\nmango.changeEmail('newmail.com'); // \"Invalid email format\"\nmango.changeEmail('new@mail.com');\nconsole.log(mango.getEmail()); // \"new@mail.com\" */\n\n// Прямий виклик приватного методу ззовні призведе до помилки\n\n// #endregion\n\n// #region  //: - Геттери і сеттери\n\n//^ Геттер і сеттер повинні називатися однаково.\n//^ Краще називати геттери і сеттери так само, як і властивість, з якою вони працюють. Геттер може існувати без сеттера, так само як і сеттер без геттера.\n//; 1\n\n/* class User {\n  #email;\n\n  constructor(params) {\n    this.name = params.name;\n    this.#email = params.email;\n  }\n\n  // Геттер email\n  get email() {\n    return this.#email;\n  }\n\n  // Сеттер email\n  set email(newEmail) {\n    this.#email = newEmail;\n  }\n}\n\nconst mango = new User({\n  name: 'Mango',\n  email: 'mango@mail.com',\n});\n\nconsole.log(mango.email); // mango@mail.com\n\nmango.email = 'mango@supermail.com';\n\nconsole.log(mango.email); // mango@supermail. */\n\n//; 2\n\n/* set email(newEmail) {\n  if(newEmail === \"\") {\n    console.log(\"Помилка! Пошта не може бути порожнім рядком!\");\n    return;\n  }\n\n  this.#email = newEmail;\n} */\n// #endregion\n\n// #region  //: - Статичні властивості\n\n// Властивості, що доступні тільки класові, але не його екземплярам — це статичні властивості. Вони корисні для зберігання інформації, що стосується класу.\n\n//^ оголошення статичної static - оголошується в тілі класу\n\n//; 1\n/* class MyClass {\n  static myPop = 'value';\n}\n\nconsole.log(MyClass.myProp);\n */\n//^ у екземпляра немає доступу до статичних властивостей класу\n//; 2\n/* class MyClass {\n  static myProp = 'value';\n}\nconst inst = newMyClass();\nconsole.log(inst.myProp); */\n\n//; 3\n\n/* class User {\n  static roles = {\n    admin: 'admin',\n    editor: 'editor',\n    basic: 'basic',\n  };\n\n  #email;\n  #role;\n\n  constructor(params) {\n    this.#email = params.email;\n    this.#role = params.role || User.roles.basic;\n  }\n\n  get role() {\n    return this.#role;\n  }\n\n  set role(newRole) {\n    this.#role = newRole;\n  }\n\n  get email() {\n    return this.#email;\n  }\n\n  set email(newEmail) {\n    this.#email = newEmail;\n  }\n}\n\nconst mango = new User({\n  email: 'mango@gmail.com',\n  role: User.roles.admin,\n});\n\nconsole.log(mango.role); // \"admin\"\nmango.role = User.roles.editor;\nconsole.log(mango.role); // \"editor\"\nmango.role = User.roles.basic;\nconsole.log(mango.role); // \"basic\nmango.email = 'new email';\n\nconsole.log(mango.email); */\n\n//; 4\n\n/* class Car {\n  static maxPrice = 50000;\n  #price;\n\n  constructor(params) {\n    this.#price = params.price;\n  }\n\n  get price() {\n    return this.#price;\n  }\n\n  set price(newPrice) {\n    if (newPrice <= Car.maxPrice) {\n      this.#price = newPrice;\n    }\n  }\n}\n\nconst audi = new Car({ price: 35000 });\nconsole.log(audi.price); // 35000\n\naudi.price = 49000;\nconsole.log(audi.price); // 49000\n\naudi.price = 51000;\nconsole.log(audi.price); // 49000 */\n\n// #endregion\n\n// #region  //: - Статичні методи\n\n//; 1\n\n/* class MyClass {\n  static myMethod() {\n    console.log('A static method');\n  }\n}\n\nMyClass.myMethod(); // A static method */\n\n//; 2\n//^ Особливість статичних методів\n//^Під час їх виклику ключове слово this посилається на сам клас. Це означає, що статичний //^метод може отримати доступ до статичних властивостей класу, але не до\n//^властивостей екземпляра. Це логічно, адже статичні методи викликає сам клас, а не його екземпляри.\n/* class User {\n  static #takenEmails = [];\n\n  static isEmailTaken(email) {\n    return User.#takenEmails.includes(email);\n  }\n\n  #email;\n\n  constructor(params) {\n    this.#email = params.email;\n    User.#takenEmails.push(params.email);\n  }\n}\n\nconst mango = new User({ email: 'mango@mail.com' });\n\nconsole.log(User.isEmailTaken('poly@mail.com')); // false\nconsole.log(User.isEmailTaken('mango@mail.com')); // true\n */\n\n//; 3\n\n/* class Car {\n  static #maxPrice = 50000;\n  static checkPrice(price) {\n    if (price > Car.#maxPrice) {\n      return 'Error! Price exceeds the maximum';\n    } else {\n      return 'Success! Price is within acceptable limits';\n    }\n  }\n\n  constructor(params) {\n    this.price = params.price;\n  }\n}\n\nconst audi = new Car({ price: 36000 });\nconst bmw = new Car({ price: 64000 });\n\nconsole.log(Car.checkPrice(audi.price)); // \"Success! Price is within acceptable limits\"\nconsole.log(Car.checkPrice(bmw.price)); // \"Error! Price exceeds the maximum\" */\n\n// #endregion\n\n// #region  //: - Наслідування класів\n//? Ключове слово extends дозволяє реалізувати наслідування класів, коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).\n\n//; 1\n/* class Parent { }\nclass Child extends Parent {\n  //\n} */\n\n//; 2\n\n/* class User {\n  #email;\n\n  constructor(email) {\n    this.#email = email;\n  }class\n\n  get email() {\n    return this.#email;\n  }\n\n  set email(newEmail) {\n    this.#email = newEmail;\n  }\n}\n\nclass ContentEditor extends User {\n  // тіло класу ContentEditor\n}\n\nconst editor = new ContentEditor('mango@mail.com');\n\nconsole.log(editor); // { #email: \"mango@mail.com\" }\nconsole.log(editor.email); // \"mango@mail.com\" */\n\n//;\n\n/* class User {\n  constructor(email) {\n    this.email = email;\n  }\n\n  get email() {\n    return this.email;\n  }\n\n  set email(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nclass Admin extends User {\n  static role = {\n    BASIC: 'basic',\n    SUPERUSER: 'superuser',\n  };\n}\n\nconsole.log(Admin.role.BASIC); */\n\n// #endregion\n\n// #region  //: - Конструктор дочірнього класу\n\n//У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.\n//В іншому випадку при спробі звернутися до this у конструкторі дочірнього класу виникне помилка.\n\n//; 1\n\n/* class User {\n  #email;\n\n  constructor(email) {\n    this.#email = email;\n  }\n\n  get email() {\n    return this.#email;\n  }\n\n  set email(newEmail) {\n    this.#email = newEmail;\n  }\n}\n\nclass ContentEditor extends User {\n  constructor(params) {\n    super(params.email);\n\n    this.posts = params.posts;\n  }\n}\n\nconst editor = new ContentEditor({\n  email: 'mango@sda',\n  posts: [],\n});\n\nconsole.log(editor);\nconsole.log(editor.email); */\n\n//; 2\n\n/* class User {\n  email;\n\n  constructor(email) {\n    this.email = email;\n  }\n\n  get email() {\n    return this.email;\n  }\n\n  set email(newEmail) {\n    this.email = newEmail;\n  }\n}\n\nclass Admin extends User {\n  static role = {\n    BASIC: 'basic',\n    SUPERUSER: 'superuser',\n  };\n  access;\n  constructor(params) {\n    super(params.email);\n    this.access = params.access;\n  }\n}\n\nconst mango = new Admin({\n  email: 'mango@mail.com',\n  access: Admin.role.SUPERUSER,\n});\n\nconsole.log(mango.email); // \"mango@mail.com\"\nconsole.log(mango.access); // \"superuser\" */\n\n// #endregion\n\n// #region  //: - Методи дочірнього класу\n// ? Дочірній клас може використовувати методи та властивості батьківського класу. Крім цього, у дочірньому класі можна оголошувати методи, які будуть доступні тільки його екземплярам.\n\n/* class User {\n  email;\n\n  constructor(email) {\n    this.email = email;\n  }\n\n  get email() {\n    return this.email;\n  }\n\n  set email(newEmail) {\n    this.email = newEmail;\n  }\n}\nclass Admin extends User {\n  static role = {\n    BASIC: 'basic',\n    SUPERUSER: 'superuser',\n  };\n\n  blacklistedEmails = [];\n\n  constructor(params) {\n    super(params.email);\n    this.access = params.access;\n  }\n\n  blacklist(email) {\n    this.blacklistedEmails.push(email);\n  }\n\n  isBlacklisted(email) {\n    return this.blacklistedEmails.includes(email);\n  }\n}\n\nconst mango = new Admin({\n  email: 'mango@mail.com',\n  access: Admin.role.SUPERUSER,\n});\n\nconsole.log(mango.email); // \"mango@mail.com\"\nconsole.log(mango.access); // \"superuser\"\n\nmango.blacklist('poly@mail.com');\nconsole.log(mango.blacklistedEmails); // [\"poly@mail.com\"]\nconsole.log(mango.isBlacklisted('mango@mail.com')); // false\nconsole.log(mango.isBlacklisted('poly@mail.com')); // true */\n\n// #endregion\n\n//; 5 ------ Задачі -------\n\n// #region  //; - Задачі\n\n// #endregion\n","//; Module № 8. Події та бібліотеки\n\n//! 1 ------ Делегування подій  -------\n\n// #region  //: - Поширення подій\n\n/* const parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\nconst descendant = document.querySelector('#descendant');\n\nparent.addEventListener('click', () => {\n  console.log('1 Parent');\n});\n\nchild.addEventListener('click', () => {\n  console.log('2 Child');\n});\n\ndescendant.addEventListener('click', () => {\n  console.log('3 Descendant');\n}); */\n\n// #endregion\n\n// #region  //: - Цільовий елемент (event.target, event.currentTarget)\n\n//; event.target\n//; event.currentTarget\n\n//? event.target  елемент який викликав подію наприклад клік\n//? event.currentTarget це там де знаходиться listener\n\n/* const parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\nconst descendant = document.querySelector('#descendant');\n\nparent.addEventListener('click', event => {\n  console.log('event.target: ', event.target);\n  console.log('event.currrentTarget: ', event.currentTarget);\n}); */\n\n// #endregion\n\n// #region  //: - Припинення спливання\n\n//; event.stopPropagation()\n//; event.stopImmediatePropagation()\n\n/* const parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\nconst descendant = document.querySelector('#descendant');\n\nparent.addEventListener('click', () => {\n  console.log('1 parent');\n\n  alert(\n    'Parent click handler. This alert will not appear when clicking on Descendant, the event will not reach here!'\n  );\n});\n\nchild.addEventListener('click', () => {\n  console.log('2 child');\n\n  alert(\n    'Child click handler. This alert will not appear when clicking on Descendant, the event will not reach here!'\n  );\n});\n\ndescendant.addEventListener('click', event => {\n  event.stopPropagation();\n  alert('Descendant click handler');\n  console.log('3 descendant');\n});\n */\n// #endregion\n\n// #region  //: - Делегування подій\n\n//? 3 кроки реалізації деоегування подій\n//? Визначити спільного предка групи елементів для відстеження подій\n//? Зареєеструвати на елементі-предку обробник події яку ми хочемо відловлювати з групи елементів\n//? В обробнику використовувати event.target для вибору цільового елемента, на якому відбувається подія\n\n//; приклад\n/* const box = document.querySelector('.box');\n\nbox.addEventListener('click', event => {\n  console.log(event.target);\n});\n */\n// #endregion\n\n// #region  //: - Перевірка цільового елемента події\n\n/* //* пошук обєктів\nconst colorPalette = document.querySelector('.color-palette');\nconst output = document.querySelector('.output');\n\n//* слухач при кліку активується функція\ncolorPalette.addEventListener('click', selectColor);\n\n//* ця функція активується при кліку яка\n// перевіряє чи івент находиться на кнопці та присваює колір\n// із дата сет колор який був створений до цього в createPaletteItems()\n//\nfunction selectColor(event) {\n  if (event.target.nodeName !== 'BUTTON') {\n    return; // якщо імя тегу не баттон то припини\n  }\n\n  const selectedColor = event.target.dataset.color;\n  output.textContent = `Selected color: ${selectedColor}`;\n  output.style.color = selectedColor;\n}\n\n//* ця функція сразу викликається і енерує палети\n// такоє активує іншу функцію getRandomHexColor() для тсворення рандомного кольору\n\ncreatePaletteItems();\n\nfunction createPaletteItems() {\n  const items = [];\n  for (let i = 0; i < 60; i++) {\n    const color = getRandomHexColor();\n    const item = document.createElement('button');\n    item.type = 'button';\n    item.dataset.color = color;\n    item.style.backgroundColor = color;\n    item.classList.add('item');\n    items.push(item);\n  }\n  colorPalette.append(...items);\n}\n\n//*  для створення рандомного кольору\nfunction getRandomHexColor() {\n  const letters = '0123456789ABCDEF';\n  let color = '#';\n\n  for (let i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n\n  return color;\n} */\n\n// #endregion\n\n//! 2 ------  Бібліотеки -------\n\n// #region  //^ - Бібліотеки\n\n// #endregion\n\n// #region  //^ - CDN (Content Delivery Network)\n\n// #endregion\n\n// #region  //: - Підключення бібліотеки\n/* import * as basicLightbox from 'basiclightbox'; */\n\n/* import * as basicLightbox from 'basiclightbox';\n\nconst instance = basicLightbox.create(`\n    <img src=\"assets/images/image.png\" width=\"800\" height=\"600\">\n`);\n\ninstance.show(); */\n\n// #endregion\n\n//! 3 ------ Деструктуризація -------\n\n// #region  //: - Навіщо потрібна деструктуризація?\n\n/* const user = {\n  name: 'Jacob',\n  age: 32,\n};\n\n//? Без деструктиризації\n\nconsole.log(user.name);\nconsole.log(user.age);\n\n//? із деструктиризацією\nconst { name, age } = user;\n\nconsole.log(name);\nconsole.log(age); */\n\n// #endregion\n\n// #region  //: - Деструктуризація об'єктів\n\n/* const book = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  isPublic: true,\n  rating: 8.38,\n};\n */\n/* const accessType = book.isPublic ? 'pulbic' : 'private';\nconst message = `Book ${book.title} by author ${book.author} with rating ${book.rating} is in ${accessType} access!`; */\n\n/* const { title, author, genres, isPublic, rating } = book;\n\nconst accessType = isPublic ? 'public' : 'private';\nconst message = `Book ${title} by author ${author} with rating ${rating} is in ${accessType} access`;\n\nconsole.log(message);\n */\n// #endregion\n\n// #region  //: - Деструктуризація неіснуючих властивостей\n\n//? якщо в обєкті нема значення яке в казано підч ас дестрк то буде undefined тому потрібно ставити = чомусь\n\n/* const book = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n};\n\n// Додамо зображення обкладинки, якщо вона відсутня в об'єкті книги\nconst {\n  title,\n  author,\n  coverImage = 'https://via.placeholder.com/640/480', // тут додате зображення\n} = book;\n\nconsole.log(title); // \"The Last Kingdom\"\nconsole.log(author); // \"Bernard Cornwell\"\nconsole.log(coverImage); // \"https://via.placeholder.com/640/480\" */\n\n// #endregion\n\n// #region  //: - Перейменування змінної\n\n//^ Для цього пишемо:\n//^ ім'я властивості, з якої хочемо отримати значення\n//^ ставимо двокрапку :\n//^ пишемо ім'я змінної, в яку необхідно помістити значення цієї властивості.\n\n/* const book = {\n  title: 'The Last Kingdom',\n  author: 'Bernard Cornwell',\n  genres: ['historical prose', 'adventure'],\n  isPublic: true,\n  rating: 8.38,\n};\n\nconst { title, author: bookAuthor, isPublic, genres: allGenres, rating } = book;\n\nconsole.log(title);\nconsole.log(bookAuthor); // переіменовано\nconsole.log(isPublic);\nconsole.log(allGenres); // переіменовано\nconsole.log(rating); */\n\n// #endregion\n\n// #region  //: - Значення за замовчуванням\n\n//? При перейменуванні змінної, в яку ми розпаковуємо значення властивості об'єкта, також можна присвоїти значення за замовчуванням.\n\n//; 1\n/* const book = {\n  title: 'The Last Kingdom',\n  coverImage: ' - http old image', // якщо значення вже є то воно буде відображатися\n};\n\nconst { title, coverImage: bookCoverImage = ' - http new image ' } = book;\n\nconsole.log(title, bookCoverImage);\n */\n//; 1.2\n\n/* const book = {\n  title: 'The Last Kingdom',\n};\n\nconst { title, coverImage: bookCoverImage = ' - http new image ' } = book;\n\nconsole.log(title, bookCoverImage); */\n\n// #endregion\n\n// #region  //: - Деструктуризація в циклах\n\nconst books = [\n  {\n    title: 'The Last Kingdom',\n    author: 'Bernard Cornwell',\n    rating: 8.38,\n  },\n  {\n    title: 'Beside Still Waters',\n    author: 'Robert Sheckley',\n    rating: 8.51,\n  },\n];\n\n//; старий приклад\n/* for (const book of books) {\n  console.log(book.title);\n  console.log(book.author);\n  console.log(book.rating);\n} */\n\n//; новий\n\n/* for (const book of books) {\n  const { title, author, rating } = book; // зверни увагу тут один обкт Із масиву\n  console.log(title);\n  console.log(author);\n  console.log(rating);\n}\n */\n//; якщо не багато властивостей то можна і коротше\n\n/* for (const { title, author, rating } of books) {\n  // тут вписуємо заміть book\n  console.log(title);\n  console.log(author);\n  console.log(rating);\n}\n */\n// #endregion\n\n// #region  //: - Деструктуризація параметрів\n\n//; Без деструктуризації об'єкта:\n\n/* function printUserInfo(user) {\n  console.log(`Name: ${user.name}, Age: ${user.age}, Hobby: ${user.hobby}`);\n}\n\nprintUserInfo({\n  name: 'Alice', age: 25, hobby: 'dancing'\n}); */\n// Name: Alice, Age: 25, Hobby: dancing\n\n//; З деструктуризацією об'єкта в тілі функції:\n\n/* function printUserInfo(user) {\n  const { name, age, hobby } = user;\n  console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);\n}\n\nprintUserInfo({\n  name: 'Alice',\n  age: 24,\n  hobby: 'dancing',\n}); */\n\n//; Із деструктуризацією об'єкта в місці оголошення параметрів:\n\n/* function printUserInfo({ name, age, hobby }) {\n  console.log(`Name: ${name}, Age: ${age}, Hobby: ${hobby}`);\n}\n\nprintUserInfo({\n  name: 'Alice',\n  age: 25,\n  hobby: 'dancing',\n}); */\n// #endregion\n\n// #region  //: - Патерн «Об'єкт параметрів»\n\n//^ Якщо функція приймає більше 2-3 параметрів, дуже просто заплутатися, в якій послідовності і що передавати.\n\n//; В результаті виходить дуже неочевидний код у місці її виклику.\n/* function doStuffWithBook(title, pages, downloads, rating, isPublic) {\n  // Робимо щось з параметрами\n  console.log(title);\n  console.log(numberOfPages);\n  // І так далі\n}\n\n// ❌ Що таке 736? Що таке 10283? Що таке true?\ndoStuffWithBook('The Last Kingdom', 736, 10283, 8.38, true); */\n\n//; Патерн «Об'єкт параметрів» допомагає вирішити цю проблему.\n\n/* function doStuffWithBook(book) {\n  // Він заміняє набір параметрів всього одним — об'єктом з іменованими властивостями.\n  // Робимо щось з властивостями об'єкта\n  console.log(book.title);\n  console.log(book.pages);\n  // І так далі\n}\n\n// ✅ Все зрозуміло\ndoStuffWithBook({\n  title: 'The Last Kingdom',\n  pages: 736,\n  downloads: 10283,\n  rating: 8.38,\n  isPublic: true,\n}); */\n\n//; Ще одна перевага в тому, що можна деструктуризувати об'єкт у параметрі book.\n\n/* function doStuffWithBook(book) {\n  const { title, pages, downloads, rating, isPublic } = book;\n  console.log(title);\n  console.log(pages);\n} */\n\n// ? Або в сигнатурі (підписі) функції — різниці немає.\n\n/* function doStuffWithBook({ title, pages, downloads, rating, isPublic }) {\n  console.log(title);\n  console.log(pages);\n}\n */\n// #endregion\n\n// #region  //: - Глибока деструктуризація\n\n//^ Найчастіше дані будуть представлені об'єктами з більш ніж одним рівнем вкладеності.\n/* const user = {\n  name: 'Jacques Gluke',\n  tag: 'jgluke',\n  stats: {\n    followers: 5603,\n    views: 4827,\n    likes: 1308,\n  },\n}; */\n\n//; Для початку напишемо код деструктуризації властивостей об'єкта користувача.\n/* const user = {\n  name: 'Jacques Gluke',\n  tag: 'jgluke',\n  stats: {\n    followers: 5603,\n    views: 4827,\n    likes: 1308,\n  },\n}; */\n\n/* const { name, tag, stats } = user;\nconsole.log(name); // Jacques Gluke\nconsole.log(tag); // jgluke\nconsole.log(stats); // { followers: 5603, views: 4827, likes: 1308 } */\n\n//; Тепер додамо глибоку деструктуризацію властивостей об'єкта stats.\n\n/* const {\n  name,\n  tag,\n  stats: { followers, views, likes },\n} = user;\n\nconsole.log(name); // Jacques Gluke\nconsole.log(tag); // jgluke\nconsole.log(followers); // 5603\nconsole.log(views); // 4827\nconsole.log(likes); // 1308 */\n\n//; Під час глибокої деструктуризації також можна змінювати імена змінних і присвоювати значення за замовчуванням, використовуючи вже знайомий тобі синтаксис.\n\nconst user = {\n  name: 'Jacques Gluke',\n  tag: 'jgluke',\n  stats: {\n    followers: 5603,\n    views: 4827,\n  },\n};\n\nconst {\n  name,\n  tag,\n  stats: { followers = 0, views: userViews = 0, likes: userLikes = 0 },\n} = user;\n\nconsole.log(name); // Jacques Gluke\nconsole.log(tag); // jgluke\nconsole.log(followers); // 5603\nconsole.log(userViews); // 4827 //? нове\nconsole.log(userLikes); // 0 //? нове видаив значення перед цим це як дефолтне\n\n// #endregion\n\n//! 4 ------   Деструктуризація масивів -------\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //: -\n\n// #endregion\n\n// #region  //; - Задачі\n\n// #endregion\n"],"names":["employee","user","name","tag","followers","userViews","userLikes"],"mappings":"0uBAqQA;AAiMA;AAsBA,MAAMA,EAAW,CACf,WAAY,IACZ,SAAU,GACV,KAAM,GACN,SAAU,CACR,OAAO,KAAK,WAAa,KAAK,SAAW,KAAK,IAC/C,CACH,EAEAA,EAAS,QAAO,EAiBhB;ACrCA,MAAMC,EAAO,CACX,KAAM,gBACN,IAAK,SACL,MAAO,CACL,UAAW,KACX,MAAO,IACR,CACH,EAEM,CACJ,KAAAC,EACA,IAAAC,EACA,MAAO,CAAE,UAAAC,EAAY,EAAG,MAAOC,EAAY,EAAG,MAAOC,EAAY,CAAG,CACtE,EAAIL,EAEJ,QAAQ,IAAIC,CAAI,EAChB,QAAQ,IAAIC,CAAG,EACf,QAAQ,IAAIC,CAAS,EACrB,QAAQ,IAAIC,CAAS,EACrB,QAAQ,IAAIC,CAAS,EAIrB;"}